<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.13">
  <POU Name="FB_CameraControl" Id="{0f0399ed-b12f-4ac2-b2b2-c4d35fe2e893}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_CameraControl
VAR_INPUT
    // Program commands (for auto mode)
    pcmdTrigger           : BOOL;   // Command to trigger the camera in auto mode
    pcmdReset             : BOOL;   // Command to reset the state machine and reset errors on the camera

    // Operator commands (for manual mode)
    ocmdSetAuto           : BOOL;   // Command to switch to auto mode, only if we are in Idle
    ocmdSetManual         : BOOL;   // Command to switch to manual mode, only if we are in Idle
    ocmdTrigger           : BOOL;   // Command to trigger the camera in manual mode
    ocmdReset             : BOOL;   // Command to reset the state machine and reset errors on the camera

END_VAR

VAR_OUTPUT
    // Status outputs
    stsInspectionRunning    : BOOL;  // Indicates that inspection is in progress
    stsError                : BOOL;  // Indicates an error has occurred
    stsReadyToTrigger       : BOOL;  // No errors, no active inspection, ready to trigger
    stsModeAuto             : BOOL;  // Indicates the system is in auto mode
    stsModeManual           : BOOL;  // Indicates the system is in manual mode
    stsInspectionResults    : ARRAY[1..10] OF INT;  // Array for storing the 10 inspection results

END_VAR

VAR
    // Internal variables
    internalActiveStep      : INT := 0;   // Current active step in the state machine
    internalNextStep        : INT := 0;   // Next step in the state machine
    internalAutoMode        : BOOL := FALSE;  // Internal flag to indicate auto mode
    internalManualMode      : BOOL := FALSE;  // Internal flag to indicate manual mode
    i                       : INT := 0;      // Iterator for array operations

END_VAR

// Constants for the state machine steps
VAR CONSTANT
    STEP_IDLE              : INT := 0;
    STEP_READY_TO_TRIGGER  : INT := 1;
    STEP_TRIGGERING        : INT := 2;
    STEP_ACQUIRING         : INT := 3;
    STEP_WAIT_RESULTS      : INT := 4;
    STEP_PROCESS_RESULTS   : INT := 5;
    STEP_ERROR             : INT := 6;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Main Logic
IF ocmdReset OR pcmdReset THEN
    // Reset the system and clear the errors
    internalActiveStep := STEP_IDLE;
    stsError := FALSE;
    stsInspectionRunning := FALSE;
    IO_Mapping.outTriggerCamera := FALSE;
    stsReadyToTrigger := TRUE;

    // Clear the inspection results
    FOR i := 1 TO 10 DO
        stsInspectionResults[i] := 0;
    END_FOR;

    internalAutoMode := FALSE;
    internalManualMode := FALSE;
    stsModeAuto := FALSE;
    stsModeManual := FALSE;

ELSIF ocmdSetAuto AND (internalActiveStep = STEP_IDLE) THEN
    // Set the system to auto mode
    internalAutoMode := TRUE;
    internalManualMode := FALSE;
    stsModeAuto := TRUE;
    stsModeManual := FALSE;
    stsReadyToTrigger := TRUE;

ELSIF ocmdSetManual AND (internalActiveStep = STEP_IDLE) THEN
    // Set the system to manual mode
    internalManualMode := TRUE;
    internalAutoMode := FALSE;
    stsModeManual := TRUE;
    stsModeAuto := FALSE;
    stsReadyToTrigger := TRUE;

ELSIF internalAutoMode THEN
    // Auto mode sequence (responds to pcmdTrigger command)
    CASE internalActiveStep OF
        STEP_IDLE:
            IF pcmdTrigger AND IO_Mapping.inpTriggerReady THEN
                internalNextStep := STEP_READY_TO_TRIGGER;
            END_IF;

        STEP_READY_TO_TRIGGER:
            IF pcmdTrigger THEN
                IO_Mapping.outTriggerCamera := TRUE;
                internalNextStep := STEP_TRIGGERING;
                stsReadyToTrigger := FALSE;
            END_IF;

        STEP_TRIGGERING:
            IF IO_Mapping.inpAcquiring THEN
                IO_Mapping.outTriggerCamera := FALSE;
                internalNextStep := STEP_ACQUIRING;
            END_IF;

        STEP_ACQUIRING:
            IF IO_Mapping.inpInspectionComplete THEN
                internalNextStep := STEP_WAIT_RESULTS;
            END_IF;

        STEP_WAIT_RESULTS:
            IF IO_Mapping.inpResultsValid THEN
                // Copy valid inspection results
                stsInspectionResults[1] := IO_Mapping.inpInspectionResults;
                stsInspectionResults[2] := IO_Mapping.inpInspectionResults1;
                stsInspectionResults[3] := IO_Mapping.inpInspectionResults2;
                stsInspectionResults[4] := IO_Mapping.inpInspectionResults3;
                stsInspectionResults[5] := IO_Mapping.inpInspectionResults4;
                stsInspectionResults[6] := IO_Mapping.inpInspectionResults5;
                stsInspectionResults[7] := IO_Mapping.inpInspectionResults6;
                stsInspectionResults[8] := IO_Mapping.inpInspectionResults7;
                stsInspectionResults[9] := IO_Mapping.inpInspectionResults8;
                stsInspectionResults[10] := IO_Mapping.inpInspectionResults9;

                // Acknowledge results and move to process results
                IO_Mapping.outInspectionResultsAck := TRUE;
                internalNextStep := STEP_PROCESS_RESULTS;
            END_IF;

        STEP_PROCESS_RESULTS:
            IF IO_Mapping.inpCommandComplete THEN
                internalNextStep := STEP_IDLE;
                stsInspectionRunning := FALSE;
                stsReadyToTrigger := TRUE;
            ELSE
                internalNextStep := STEP_PROCESS_RESULTS;
            END_IF;

        STEP_ERROR:
            // Handle errors, reset to idle when cleared
            stsError := TRUE;
            IF pcmdReset THEN
                stsError := FALSE;
                internalNextStep := STEP_IDLE;
            END_IF;

    END_CASE;

    // Move to the next step
    internalActiveStep := internalNextStep;

    // Status of inspection in progress
    IF internalActiveStep = STEP_ACQUIRING OR internalActiveStep = STEP_PROCESS_RESULTS THEN
        stsInspectionRunning := TRUE;
    ELSE
        stsInspectionRunning := FALSE;
    END_IF;

ELSIF internalManualMode THEN
    // Manual mode sequence (responds to ocmdTrigger command)
    CASE internalActiveStep OF
        STEP_IDLE:
            IF ocmdTrigger AND IO_Mapping.inpTriggerReady THEN
                internalNextStep := STEP_READY_TO_TRIGGER;
            END_IF;

        STEP_READY_TO_TRIGGER:
            IF ocmdTrigger THEN
                IO_Mapping.outTriggerCamera := TRUE;
                internalNextStep := STEP_TRIGGERING;
                stsReadyToTrigger := FALSE;
            END_IF;

        STEP_TRIGGERING:
            IF IO_Mapping.inpAcquiring THEN
                IO_Mapping.outTriggerCamera := FALSE;
                internalNextStep := STEP_ACQUIRING;
            END_IF;

        STEP_ACQUIRING:
            IF IO_Mapping.inpInspectionComplete THEN
                internalNextStep := STEP_WAIT_RESULTS;
            END_IF;

        STEP_WAIT_RESULTS:
            IF IO_Mapping.inpResultsValid THEN
                // Copy valid inspection results
                stsInspectionResults[1] := IO_Mapping.inpInspectionResults;
                stsInspectionResults[2] := IO_Mapping.inpInspectionResults1;
                stsInspectionResults[3] := IO_Mapping.inpInspectionResults2;
                stsInspectionResults[4] := IO_Mapping.inpInspectionResults3;
                stsInspectionResults[5] := IO_Mapping.inpInspectionResults4;
                stsInspectionResults[6] := IO_Mapping.inpInspectionResults5;
                stsInspectionResults[7] := IO_Mapping.inpInspectionResults6;
                stsInspectionResults[8] := IO_Mapping.inpInspectionResults7;
                stsInspectionResults[9] := IO_Mapping.inpInspectionResults8;
                stsInspectionResults[10] := IO_Mapping.inpInspectionResults9;

                // Acknowledge results and move to process results
                IO_Mapping.outInspectionResultsAck := TRUE;
                internalNextStep := STEP_PROCESS_RESULTS;
            END_IF;

        STEP_PROCESS_RESULTS:
            IF IO_Mapping.inpCommandComplete THEN
                internalNextStep := STEP_IDLE;
                stsInspectionRunning := FALSE;
                stsReadyToTrigger := TRUE;
            ELSE
                internalNextStep := STEP_PROCESS_RESULTS;
            END_IF;

        STEP_ERROR:
            // Handle errors, reset to idle when cleared
            stsError := TRUE;
            IF ocmdReset THEN
                stsError := FALSE;
                internalNextStep := STEP_IDLE;
            END_IF;

    END_CASE;

    // Move to the next step
    internalActiveStep := internalNextStep;

    // Status of inspection in progress
    IF internalActiveStep = STEP_ACQUIRING OR internalActiveStep = STEP_PROCESS_RESULTS THEN
        stsInspectionRunning := TRUE;
    ELSE
        stsInspectionRunning := FALSE;
    END_IF;
END_IF;
]]></ST>
    </Implementation>
    <LineIds Name="FB_CameraControl">
      <LineId Id="1284" Count="182" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>