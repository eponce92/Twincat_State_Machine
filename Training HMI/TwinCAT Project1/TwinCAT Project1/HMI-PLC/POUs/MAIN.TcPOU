<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.13">
  <POU Name="MAIN" Id="{4f4444b9-0fc9-41d2-8d8b-6376a7d4acc5}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
    // State Machine instance
    fbStateMachine : FB_StateMachine;
    
    // HMI interface for state machine
    stateMachineHMI : SM_HMI;
    
    // Current step for state machine - SHARED between state machine and all step programs
    currentStep : ActiveStep;
    
    // State machine command inputs
    smCommands : ST_SM_Commands;
      
    // Test inputs for permissions
    testAutoIntlk : INT := -1;  // All OK by default (-1 = all bits OK)
    testHomePerm : INT := -1;   // All OK by default
    testStartPerm : INT := -1;  // All OK by default
    testProceedPerm : INT := -1; // All OK by default
    
    // Next step calculation - determined by active sequence programs
    nextStepFromSequence : DINT;

END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[
//=============================================================================
// MAIN PROGRAM - State Machine Implementation with Sequence Programs
//=============================================================================

// Execute sequence programs based on current state
// Each program handles its specific state steps and returns the next step
nextStepFromSequence := 0;  // Default to no step change

// Call appropriate sequence program based on current state
IF fbStateMachine.Status.Homing THEN
    PRG_Homing(
        CurrentStep := currentStep,
        StepTimerSeconds := REAL_TO_DINT(fbStateMachine.StepInfo.StepTimerSeconds),
        RetrySignal := fbStateMachine.outRetry,
        StateMachineStatus := fbStateMachine.Status,
        NextStep => nextStepFromSequence
    );
    
ELSIF fbStateMachine.Status.Running THEN
    PRG_Running(
        CurrentStep := currentStep,
        StepTimerSeconds := REAL_TO_DINT(fbStateMachine.StepInfo.StepTimerSeconds),
        RetrySignal := fbStateMachine.outRetry,
        StateMachineStatus := fbStateMachine.Status,
        NextStep => nextStepFromSequence
    );
    
ELSIF fbStateMachine.Status.Stopping THEN
    PRG_Stopping(
        CurrentStep := currentStep,
        StepTimerSeconds := REAL_TO_DINT(fbStateMachine.StepInfo.StepTimerSeconds),
        RetrySignal := fbStateMachine.outRetry,
        StateMachineStatus := fbStateMachine.Status,
        NextStep => nextStepFromSequence
    );
    
ELSIF fbStateMachine.Status.Aborting THEN
    PRG_Aborting(
        CurrentStep := currentStep,
        StepTimerSeconds := REAL_TO_DINT(fbStateMachine.StepInfo.StepTimerSeconds),
        RetrySignal := fbStateMachine.outRetry,
        StateMachineStatus := fbStateMachine.Status,
        NextStep => nextStepFromSequence
    );
END_IF;

// Signal completion when sequence reaches final step
IF fbStateMachine.Status.Homing AND (nextStepFromSequence = 0) THEN
    smCommands.CompleteState := TRUE;
ELSIF fbStateMachine.Status.Running AND (nextStepFromSequence = 0) THEN
    smCommands.CompleteState := TRUE;
ELSIF fbStateMachine.Status.Stopping AND (nextStepFromSequence = 0) THEN
    smCommands.CompleteState := TRUE;
ELSIF fbStateMachine.Status.Aborting AND (nextStepFromSequence = 0) THEN
    smCommands.CompleteState := TRUE;
END_IF;

// Call state machine with step input from active sequence
fbStateMachine(
    EnableIn := TRUE,              // Enable the state machine
    cfgAutoRun := FALSE,           // Auto run configuration  
    inpAutoIntlk := testAutoIntlk, // Auto interlocks
    inpHomePerm := testHomePerm,   // Home permissions
    inpStartPerm := testStartPerm, // Start permissions
    inpProceedPerm := testProceedPerm, // Proceed permissions
    NextStep := nextStepFromSequence,  // Next step from active sequence program
    Commands := smCommands,        // Command inputs
    HMI := stateMachineHMI,        // HMI interface
    CurrentStep := currentStep     // Current step (shared with sequences)
);

// Auto-clear commands after processing (since Commands is input-only to state machine)
// The state machine processes the commands on the rising edge, so we can clear them immediately
IF smCommands.Start THEN
    smCommands.Start := FALSE;
END_IF;

IF smCommands.Stop THEN
    smCommands.Stop := FALSE;
END_IF;

IF smCommands.Home THEN
    smCommands.Home := FALSE;
END_IF;

IF smCommands.Abort THEN
    smCommands.Abort := FALSE;
END_IF;

IF smCommands.Pause THEN
    smCommands.Pause := FALSE;
END_IF;

IF smCommands.Proceed THEN
    smCommands.Proceed := FALSE;
END_IF;

IF smCommands.Retry THEN
    smCommands.Retry := FALSE;
END_IF;

// Note: CompleteState is managed internally by the sequence logic above

]]></ST>
    </Implementation>
    <LineIds Name="MAIN">
      <LineId Id="765" Count="13" />
      <LineId Id="223" Count="0" />
      <LineId Id="18" Count="52" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>