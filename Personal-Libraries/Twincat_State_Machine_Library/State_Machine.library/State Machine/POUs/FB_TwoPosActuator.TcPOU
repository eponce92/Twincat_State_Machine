<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.13">
  <POU Name="FB_TwoPosActuator" Id="{f0a5a9e7-3bbf-45f9-8d89-1c6a7fcbf8d3}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'hide_all_locals'}
FUNCTION_BLOCK FB_TwoPosActuator
VAR_INPUT
    // Live permissive bits for Advance and Retract
    inPermAdv : INT := -1;             // -1 means all OK
    inPermRtr : INT := -1;
    // Reset command
    cmdReset : BOOL;                   // Reset latched fault
END_VAR

VAR_IN_OUT
    actuator : ST_TwoPosActuator;      // Main actuator data structure
    IO : ST_TwoPosActuator_IO;         // IO mapping (separate for AT declarations)
END_VAR

VAR_OUTPUT
    EnableOut : BOOL;
END_VAR

VAR
    // Internal permissives FBs
    fbPermAdv : FB_Permissives;
    fbPermRtr : FB_Permissives;

    // Timers
    tonMotion : TON;

    // Edges
    rTrigAdv : R_TRIG;
    rTrigRtr : R_TRIG;
    rTrigReset : R_TRIG;

    // Latched command intents (sanitized)
    cmdDoAdvance : BOOL;
    cmdDoRetract : BOOL;

    // Selected command sources per mode
    reqAdvance : BOOL;
    reqRetract : BOOL;

    // Internal
    motionTimeoutMs : TIME;
    bothFbk : BOOL;
    noneFbk : BOOL;

    // Fault string buffer
    faultBuf : STRING(80);
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
EnableOut := actuator.enable;
IF NOT actuator.enable THEN
    // De-energize outputs when disabled
    IO.outValveAdvance := FALSE;
    IO.outValveRetract := FALSE;
    RETURN;
END_IF;

// Evaluate permissives (HMI supplies cfg, we write back sts)
fbPermAdv(inPermissives := inPermAdv, cfg := actuator.permAdvance.cfg);
actuator.permAdvance.sts.OK := fbPermAdv.stsOK;
actuator.permAdvance.sts.PermIntlk := fbPermAdv.PermStatus;

fbPermRtr(inPermissives := inPermRtr, cfg := actuator.permRetract.cfg);
actuator.permRetract.sts.OK := fbPermRtr.stsOK;
actuator.permRetract.sts.PermIntlk := fbPermRtr.PermStatus;

// Read feedbacks and simple plausibility
bothFbk := IO.inFbkAdvanced AND IO.inFbkRetracted;
noneFbk := NOT IO.inFbkAdvanced AND NOT IO.inFbkRetracted;

// Select command source by mode (auto: pcmd*, manual: ocmd*)
reqAdvance := (actuator.automatic AND actuator.pcmdAdvance) OR ((NOT actuator.automatic) AND actuator.ocmdAdvance);
reqRetract := (actuator.automatic AND actuator.pcmdRetract) OR ((NOT actuator.automatic) AND actuator.ocmdRetract);

// Edges on selected commands only
rTrigAdv(CLK := reqAdvance);
rTrigRtr(CLK := reqRetract);
rTrigReset(CLK := cmdReset);

IF rTrigReset.Q THEN
    actuator.stsFaulted := FALSE;
    actuator.faultCode := E_TwoPosActuator_Fault.None;
END_IF;

// If faulted, drop outputs and stay in Fault until reset
IF actuator.stsFaulted THEN
    IO.outValveAdvance := FALSE;
    IO.outValveRetract := FALSE;
    actuator.state := E_TwoPosActuator_State.Fault;
    RETURN;
END_IF;

// Determine sanitized commands, apply permissives
cmdDoAdvance := reqAdvance AND actuator.permAdvance.sts.OK;
cmdDoRetract := reqRetract AND actuator.permRetract.sts.OK;

// Conflicting commands (after mode selection)
IF reqAdvance AND reqRetract THEN
    actuator.stsFaulted := TRUE;
    actuator.faultCode := E_TwoPosActuator_Fault.ConflictingCommands;
    actuator.lastFaultCode := actuator.faultCode;
    IO.outValveAdvance := FALSE;
    IO.outValveRetract := FALSE;
    actuator.state := E_TwoPosActuator_State.Fault;
    RETURN;
END_IF;

// Undefined detection at rest
IF bothFbk THEN
    actuator.stsFaulted := TRUE;
    actuator.faultCode := E_TwoPosActuator_Fault.BothFeedbacksOn;
    actuator.lastFaultCode := actuator.faultCode;
    IO.outValveAdvance := FALSE;
    IO.outValveRetract := FALSE;
    actuator.state := E_TwoPosActuator_State.Fault;
    RETURN;
END_IF;

// Reset public status flags; will be set by state logic
actuator.stsAdvanced := FALSE; actuator.stsRetracted := FALSE; actuator.stsMoving := FALSE;

// Initial state inference
IF IO.inFbkRetracted AND NOT IO.inFbkAdvanced THEN
    actuator.state := E_TwoPosActuator_State.Retracted;
ELSIF IO.inFbkAdvanced AND NOT IO.inFbkRetracted THEN
    actuator.state := E_TwoPosActuator_State.Advanced;
ELSIF noneFbk THEN
    actuator.state := E_TwoPosActuator_State.Undefined;
ELSE
    // keep
END_IF;

// Motion and control
CASE actuator.state OF
    E_TwoPosActuator_State.Retracted:
        actuator.stsRetracted := TRUE; actuator.stsAdvanced := FALSE; actuator.stsMoving := FALSE;
        IO.outValveRetract := actuator.cfg.cfgHoldAtRetracted; // maintain per config
        IO.outValveAdvance := FALSE;

        // Loss of both feedbacks at rest is a fault
        IF noneFbk THEN
            actuator.stsFaulted := TRUE;
            actuator.faultCode := E_TwoPosActuator_Fault.NoFeedbackAtRest;
            actuator.lastFaultCode := actuator.faultCode;
            IO.outValveAdvance := FALSE; IO.outValveRetract := FALSE;
            actuator.state := E_TwoPosActuator_State.Fault;
            RETURN;
        END_IF;

        IF cmdDoAdvance THEN
            // Start advance
            actuator.state := E_TwoPosActuator_State.Advancing;
            actuator.stsMoving := TRUE;
            IO.outValveAdvance := TRUE;
            IO.outValveRetract := FALSE;
            motionTimeoutMs := INT_TO_TIME(actuator.cfg.cfgAdvTimeoutS) * T#1S;
            tonMotion(IN := TRUE, PT := motionTimeoutMs);
        END_IF;

    E_TwoPosActuator_State.Advanced:
        actuator.stsAdvanced := TRUE; actuator.stsRetracted := FALSE; actuator.stsMoving := FALSE;
        IO.outValveAdvance := actuator.cfg.cfgHoldAtAdvanced;
        IO.outValveRetract := FALSE;

        // Loss of both feedbacks at rest is a fault
        IF noneFbk THEN
            actuator.stsFaulted := TRUE;
            actuator.faultCode := E_TwoPosActuator_Fault.NoFeedbackAtRest;
            actuator.lastFaultCode := actuator.faultCode;
            IO.outValveAdvance := FALSE; IO.outValveRetract := FALSE;
            actuator.state := E_TwoPosActuator_State.Fault;
            RETURN;
        END_IF;

        IF cmdDoRetract THEN
            // Start retract
            actuator.state := E_TwoPosActuator_State.Retracting;
            actuator.stsMoving := TRUE;
            IO.outValveAdvance := FALSE;
            IO.outValveRetract := TRUE;
            motionTimeoutMs := INT_TO_TIME(actuator.cfg.cfgRtrTimeoutS) * T#1S;
            tonMotion(IN := TRUE, PT := motionTimeoutMs);
        END_IF;

    E_TwoPosActuator_State.Advancing:
        actuator.stsRetracted := FALSE; actuator.stsAdvanced := FALSE; actuator.stsMoving := TRUE;
        IO.outValveAdvance := TRUE; IO.outValveRetract := FALSE;
        tonMotion(IN := TRUE, PT := motionTimeoutMs);
        
        // Invalid both-feedbacks-on during motion
        IF bothFbk THEN
            actuator.stsFaulted := TRUE;
            actuator.faultCode := E_TwoPosActuator_Fault.BothFeedbacksOn;
            actuator.lastFaultCode := actuator.faultCode;
            IO.outValveAdvance := FALSE; IO.outValveRetract := FALSE;
            actuator.state := E_TwoPosActuator_State.Fault;
            RETURN;
        END_IF;

        // Success condition
        IF IO.inFbkAdvanced AND NOT IO.inFbkRetracted THEN
            actuator.state := E_TwoPosActuator_State.Advanced;
            actuator.stsMoving := FALSE;
            tonMotion(IN := FALSE, PT := motionTimeoutMs);
        ELSIF tonMotion.Q THEN
            // Timeout
            actuator.stsFaulted := TRUE;
            actuator.faultCode := E_TwoPosActuator_Fault.AdvanceTimeout;
            actuator.lastFaultCode := actuator.faultCode;
            IO.outValveAdvance := FALSE; IO.outValveRetract := FALSE;
            actuator.state := E_TwoPosActuator_State.Fault;
        END_IF;

    E_TwoPosActuator_State.Retracting:
        actuator.stsRetracted := FALSE; actuator.stsAdvanced := FALSE; actuator.stsMoving := TRUE;
        IO.outValveAdvance := FALSE; IO.outValveRetract := TRUE;
        tonMotion(IN := TRUE, PT := motionTimeoutMs);
        
        // Invalid both-feedbacks-on during motion
        IF bothFbk THEN
            actuator.stsFaulted := TRUE;
            actuator.faultCode := E_TwoPosActuator_Fault.BothFeedbacksOn;
            actuator.lastFaultCode := actuator.faultCode;
            IO.outValveAdvance := FALSE; IO.outValveRetract := FALSE;
            actuator.state := E_TwoPosActuator_State.Fault;
            RETURN;
        END_IF;

        // Success condition
        IF IO.inFbkRetracted AND NOT IO.inFbkAdvanced THEN
            actuator.state := E_TwoPosActuator_State.Retracted;
            actuator.stsMoving := FALSE;
            tonMotion(IN := FALSE, PT := motionTimeoutMs);
        ELSIF tonMotion.Q THEN
            // Timeout
            actuator.stsFaulted := TRUE;
            actuator.faultCode := E_TwoPosActuator_Fault.RetractTimeout;
            actuator.lastFaultCode := actuator.faultCode;
            IO.outValveAdvance := FALSE; IO.outValveRetract := FALSE;
            actuator.state := E_TwoPosActuator_State.Fault;
        END_IF;

    E_TwoPosActuator_State.Undefined, E_TwoPosActuator_State.Fault:
        IO.outValveAdvance := FALSE; IO.outValveRetract := FALSE;
        IF rTrigReset.Q THEN
            // Try to re-evaluate to a safe rest state using feedback
            IF IO.inFbkRetracted XOR IO.inFbkAdvanced THEN
                IF IO.inFbkRetracted THEN
                    actuator.state := E_TwoPosActuator_State.Retracted;
                ELSE
                    actuator.state := E_TwoPosActuator_State.Advanced;
                END_IF;
                actuator.stsFaulted := FALSE; actuator.faultCode := E_TwoPosActuator_Fault.None;
            END_IF;
        END_IF;
END_CASE;

// If a command was requested but permissives not OK, fault
IF reqAdvance AND NOT actuator.permAdvance.sts.OK THEN
    actuator.stsFaulted := TRUE;
    actuator.faultCode := E_TwoPosActuator_Fault.PermissivesNotOK;
    actuator.lastFaultCode := actuator.faultCode;
END_IF;
IF reqRetract AND NOT actuator.permRetract.sts.OK THEN
    actuator.stsFaulted := TRUE;
    actuator.faultCode := E_TwoPosActuator_Fault.PermissivesNotOK;
    actuator.lastFaultCode := actuator.faultCode;
END_IF;

//------------------------------------------------------------------------------
// HMI mapping
//------------------------------------------------------------------------------
actuator.HMI.stsAdvanced := actuator.stsAdvanced;
actuator.HMI.stsRetracted := actuator.stsRetracted;
actuator.HMI.stsMoving := actuator.stsMoving;
actuator.HMI.stsFaulted := actuator.stsFaulted;

CASE actuator.state OF
    E_TwoPosActuator_State.Undefined: actuator.HMI.stsStateString := 'Undefined';
    E_TwoPosActuator_State.Retracted: actuator.HMI.stsStateString := 'Retracted';
    E_TwoPosActuator_State.Advancing: actuator.HMI.stsStateString := 'Advancing';
    E_TwoPosActuator_State.Advanced:  actuator.HMI.stsStateString := 'Advanced';
    E_TwoPosActuator_State.Retracting:actuator.HMI.stsStateString := 'Retracting';
    E_TwoPosActuator_State.Fault:     actuator.HMI.stsStateString := 'Fault';
END_CASE;

// Fault string human readable
CASE actuator.faultCode OF
    E_TwoPosActuator_Fault.None:              faultBuf := '';
    E_TwoPosActuator_Fault.PermissivesNotOK:  faultBuf := 'Permissives not OK';
    E_TwoPosActuator_Fault.ConflictingCommands: faultBuf := 'Conflicting commands';
    E_TwoPosActuator_Fault.AdvanceTimeout:    faultBuf := 'Advance timeout';
    E_TwoPosActuator_Fault.RetractTimeout:    faultBuf := 'Retract timeout';
    E_TwoPosActuator_Fault.BothFeedbacksOn:   faultBuf := 'Both feedbacks ON';
    E_TwoPosActuator_Fault.NoFeedbackAtRest:  faultBuf := 'No feedback at rest';
    E_TwoPosActuator_Fault.UndefinedState:    faultBuf := 'Undefined state';
END_CASE;
actuator.HMI.faultCode := actuator.faultCode;
actuator.HMI.faultString := faultBuf;

]]></ST>
    </Implementation>
    <LineIds Name="FB_TwoPosActuator">
      <LineId Id="100" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
