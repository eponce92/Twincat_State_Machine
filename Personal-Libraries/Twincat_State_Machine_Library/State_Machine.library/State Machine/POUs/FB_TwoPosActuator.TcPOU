<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.13">
  <POU Name="FB_TwoPosActuator" Id="{A1234567-1234-1234-1234-123456789007}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'hide_all_locals'} // Hides all local variables
FUNCTION_BLOCK FB_TwoPosActuator
VAR_INPUT
    EnableIn : BOOL := TRUE;            // Enable input for the function block
    inWorkingMode : BOOL := TRUE;       // Working mode: TRUE=Auto, FALSE=Manual
    
    // Program commands (automatic mode only)
    pcmdAdvance : BOOL;                 // Program command to advance
    pcmdRetract : BOOL;                 // Program command to retract
    pcmdAllOff : BOOL;                  // Program command to turn all outputs off
    
    // Operator commands (manual mode only)
    ocmdAdvance : BOOL;                 // Operator command to advance
    ocmdRetract : BOOL;                 // Operator command to retract
    ocmdAllOff : BOOL;                  // Operator command to turn all outputs off
    
    // Reset command (both modes)
    cmdReset : BOOL;                    // Reset fault command
    
    // Permissive inputs (INT with -1 = all OK)
    inPermAdv : INT := -1;              // Advance permissives from field
    inPermRet : INT := -1;              // Retract permissives from field
    
    // Configuration
    cfg : ST_TwoPosActuator_Cfg;        // Configuration structure
END_VAR

VAR_OUTPUT
    EnableOut : BOOL;                   // Enable output
    Status : ST_TwoPosActuator_Sts;     // Status outputs (grouped)
END_VAR

VAR_IN_OUT
    IO : ST_TwoPosActuator_IO;          // IO mapping structure
    HMI : ST_TwoPosActuator_HMI;        // HMI interface
END_VAR

VAR
    // Internal state machine
    currentState : E_TwoPosActuator_State := E_TwoPosActuator_State.Undefined;
    previousState : E_TwoPosActuator_State;
    
    // Timers for motion
    advanceTimer : TON;                 // Advance timeout timer
    retractTimer : TON;                 // Retract timeout timer
    
    // Permissive handlers
    advancePermissives : FB_Permissives;
    retractPermissives : FB_Permissives;
    
    // Command processing
    activeAdvanceCmd : BOOL;            // Active advance command after mode selection
    activeRetractCmd : BOOL;            // Active retract command after mode selection
    activeAllOffCmd : BOOL;             // Active all off command after mode selection
    
    // Edge detection
    rTrigAdvanced : R_TRIG;            // Rising edge for advanced position
    rTrigRetracted : R_TRIG;           // Rising edge for retracted position
    rTrigReset : R_TRIG;               // Rising edge for reset command
    
    // Internal flags
    commandConflict : BOOL;            // TRUE when conflicting commands detected
    bothFeedbackActive : BOOL;         // TRUE when both feedbacks are active
    noFeedbackActive : BOOL;           // TRUE when no feedback is active
    
    // Fault handling
    faultLatched : BOOL;               // Latched fault flag
    lastFault : E_TwoPosActuator_Fault; // Store last fault for diagnostics
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[//-----------------------------------------------------------------------------
// Main Implementation - FB_TwoPosActuator
//-----------------------------------------------------------------------------
EnableOut := EnableIn;

// Only execute if enabled
IF EnableIn THEN
    
    //-------------------------------------------------------------------------
    // Configuration update from HMI
    //-------------------------------------------------------------------------
    cfg := HMI.cfg;
    
    //-------------------------------------------------------------------------
    // Command Mode Selection and Conflict Detection
    //-------------------------------------------------------------------------
    
    // Select active commands based on working mode
    IF inWorkingMode THEN
        // Automatic mode - only listen to program commands
        activeAdvanceCmd := pcmdAdvance;
        activeRetractCmd := pcmdRetract;
        activeAllOffCmd := pcmdAllOff;
    ELSE
        // Manual mode - listen to operator commands (both input and HMI)
        activeAdvanceCmd := ocmdAdvance OR HMI.ocmdAdvance;
        activeRetractCmd := ocmdRetract OR HMI.ocmdRetract;
        activeAllOffCmd := ocmdAllOff OR HMI.ocmdAllOff;
    END_IF;
    
    // Clear HMI commands after reading (only in manual mode)
    IF NOT inWorkingMode THEN
        IF HMI.ocmdAdvance THEN
            HMI.ocmdAdvance := FALSE;
        END_IF;
        
        IF HMI.ocmdRetract THEN
            HMI.ocmdRetract := FALSE;
        END_IF;
        
        IF HMI.ocmdAllOff THEN
            HMI.ocmdAllOff := FALSE;
        END_IF;
    END_IF;
    
    // Detect conflicting commands (advance and retract cannot be active together)
    commandConflict := activeAdvanceCmd AND activeRetractCmd;
    
    // If conflicting commands detected, clear both and fault
    IF commandConflict THEN
        activeAdvanceCmd := FALSE;
        activeRetractCmd := FALSE;
        activeAllOffCmd := FALSE;
        currentState := E_TwoPosActuator_State.Fault;
        Status.faultCode := E_TwoPosActuator_Fault.ConflictingCommands;
        faultLatched := TRUE;
    END_IF;
    
    // Handle All Off command - overrides other commands and forces safe state
    IF activeAllOffCmd THEN
        activeAdvanceCmd := FALSE;
        activeRetractCmd := FALSE;
        // Note: All Off doesn't change state, just forces outputs off
    END_IF;
    
    //-------------------------------------------------------------------------
    // Permissive Evaluation
    //-------------------------------------------------------------------------
    
    // Advance permissives
    advancePermissives(
        inPermissives := inPermAdv,
        cfg := HMI.advancePerms.cfg
    );
    HMI.advancePerms.sts.OK := advancePermissives.stsOK;
    HMI.advancePerms.sts.PermIntlk := advancePermissives.PermStatus;
    
    // Retract permissives
    retractPermissives(
        inPermissives := inPermRet,
        cfg := HMI.retractPerms.cfg
    );
    HMI.retractPerms.sts.OK := retractPermissives.stsOK;
    HMI.retractPerms.sts.PermIntlk := retractPermissives.PermStatus;
    
    //-------------------------------------------------------------------------
    // Feedback Analysis
    //-------------------------------------------------------------------------
    
    // Analyze feedback conditions
    bothFeedbackActive := IO.inFbkAdvanced AND IO.inFbkRetracted;
    noFeedbackActive := NOT IO.inFbkAdvanced AND NOT IO.inFbkRetracted;
    
    //-------------------------------------------------------------------------
    // Reset Command Processing
    //-------------------------------------------------------------------------
    
    rTrigReset(CLK := cmdReset OR HMI.ocmdReset);
    IF rTrigReset.Q AND faultLatched THEN
        // Clear fault if conditions are safe
        IF NOT commandConflict AND NOT bothFeedbackActive THEN
            faultLatched := FALSE;
            lastFault := Status.faultCode;
            Status.faultCode := E_TwoPosActuator_Fault.None;
            currentState := E_TwoPosActuator_State.Undefined;
        END_IF;
    END_IF;
    
    // Clear HMI reset command
    IF HMI.ocmdReset THEN
        HMI.ocmdReset := FALSE;
    END_IF;
    
    //-------------------------------------------------------------------------
    // State Machine Logic
    //-------------------------------------------------------------------------
    
    // Store previous state for transition detection
    previousState := currentState;
    
    CASE currentState OF
        
        E_TwoPosActuator_State.Undefined:
            //---------------------------------------------------------------------
            // UNDEFINED STATE - Determine initial state based on feedback
            //---------------------------------------------------------------------
            
            // De-energize both outputs in undefined state
            IO.outValveAdvance := FALSE;
            IO.outValveRetract := FALSE;
            
            // Override outputs if All Off command is active
            IF activeAllOffCmd THEN
                IO.outValveAdvance := FALSE;
                IO.outValveRetract := FALSE;
            END_IF;
            
            // Check for fault conditions first
            IF bothFeedbackActive THEN
                currentState := E_TwoPosActuator_State.Fault;
                Status.faultCode := E_TwoPosActuator_Fault.BothFeedbackOn;
                faultLatched := TRUE;
            
            // Determine state based on single feedback
            ELSIF IO.inFbkAdvanced AND NOT IO.inFbkRetracted THEN
                currentState := E_TwoPosActuator_State.Advanced;
            
            ELSIF IO.inFbkRetracted AND NOT IO.inFbkAdvanced THEN
                currentState := E_TwoPosActuator_State.Retracted;
            
            // Handle commands from undefined state with no clear feedback
            ELSIF activeAdvanceCmd AND advancePermissives.stsOK THEN
                currentState := E_TwoPosActuator_State.Advancing;
            
            ELSIF activeRetractCmd AND retractPermissives.stsOK THEN
                currentState := E_TwoPosActuator_State.Retracting;
            
            // Stay in undefined if no feedback and no commands
            END_IF;
        
        E_TwoPosActuator_State.Retracted:
            //---------------------------------------------------------------------
            // RETRACTED STATE
            //---------------------------------------------------------------------
            
            // Handle hold configuration
            IF cfg.cfgHoldAtRetracted AND NOT activeAllOffCmd THEN
                IO.outValveRetract := TRUE;
            ELSE
                IO.outValveRetract := FALSE;
            END_IF;
            IO.outValveAdvance := FALSE;
            
            // Check for fault conditions
            IF bothFeedbackActive THEN
                currentState := E_TwoPosActuator_State.Fault;
                Status.faultCode := E_TwoPosActuator_Fault.BothFeedbackOn;
                faultLatched := TRUE;
            
            ELSIF NOT IO.inFbkRetracted THEN
                currentState := E_TwoPosActuator_State.Fault;
                Status.faultCode := E_TwoPosActuator_Fault.UndefinedState;
                faultLatched := TRUE;
            
            // Handle advance command
            ELSIF activeAdvanceCmd THEN
                IF advancePermissives.stsOK THEN
                    currentState := E_TwoPosActuator_State.Advancing;
                ELSE
                    currentState := E_TwoPosActuator_State.Fault;
                    Status.faultCode := E_TwoPosActuator_Fault.PermissivesNotOK;
                    faultLatched := TRUE;
                END_IF;
            END_IF;
        
        E_TwoPosActuator_State.Advancing:
            //---------------------------------------------------------------------
            // ADVANCING STATE
            //---------------------------------------------------------------------
            
            // Energize advance valve
            IO.outValveAdvance := NOT activeAllOffCmd;
            IO.outValveRetract := FALSE;
            
            // Run advance timer
            advanceTimer(IN := TRUE, PT := DINT_TO_TIME(cfg.cfgAdvTimeoutS * 1000));
            
            // Check for successful advance
            IF IO.inFbkAdvanced AND NOT IO.inFbkRetracted THEN
                currentState := E_TwoPosActuator_State.Advanced;
                advanceTimer(IN := FALSE); // Reset timer
            
            // Check for timeout
            ELSIF advanceTimer.Q THEN
                currentState := E_TwoPosActuator_State.Fault;
                Status.faultCode := E_TwoPosActuator_Fault.AdvanceTimeout;
                faultLatched := TRUE;
                advanceTimer(IN := FALSE); // Reset timer
            
            // Check for fault conditions during motion
            ELSIF bothFeedbackActive THEN
                currentState := E_TwoPosActuator_State.Fault;
                Status.faultCode := E_TwoPosActuator_Fault.BothFeedbackOn;
                faultLatched := TRUE;
                advanceTimer(IN := FALSE); // Reset timer
            
            // Check if permissives are lost during motion
            ELSIF NOT advancePermissives.stsOK THEN
                currentState := E_TwoPosActuator_State.Fault;
                Status.faultCode := E_TwoPosActuator_Fault.PermissivesNotOK;
                faultLatched := TRUE;
                advanceTimer(IN := FALSE); // Reset timer
            END_IF;
        
        E_TwoPosActuator_State.Advanced:
            //---------------------------------------------------------------------
            // ADVANCED STATE
            //---------------------------------------------------------------------
            
            // Handle hold configuration
            IF cfg.cfgHoldAtAdvanced AND NOT activeAllOffCmd THEN
                IO.outValveAdvance := TRUE;
            ELSE
                IO.outValveAdvance := FALSE;
            END_IF;
            IO.outValveRetract := FALSE;
            
            // Check for fault conditions
            IF bothFeedbackActive THEN
                currentState := E_TwoPosActuator_State.Fault;
                Status.faultCode := E_TwoPosActuator_Fault.BothFeedbackOn;
                faultLatched := TRUE;
            
            ELSIF NOT IO.inFbkAdvanced THEN
                currentState := E_TwoPosActuator_State.Fault;
                Status.faultCode := E_TwoPosActuator_Fault.UndefinedState;
                faultLatched := TRUE;
            
            // Handle retract command
            ELSIF activeRetractCmd THEN
                IF retractPermissives.stsOK THEN
                    currentState := E_TwoPosActuator_State.Retracting;
                ELSE
                    currentState := E_TwoPosActuator_State.Fault;
                    Status.faultCode := E_TwoPosActuator_Fault.PermissivesNotOK;
                    faultLatched := TRUE;
                END_IF;
            END_IF;
        
        E_TwoPosActuator_State.Retracting:
            //---------------------------------------------------------------------
            // RETRACTING STATE
            //---------------------------------------------------------------------
            
            // Energize retract valve
            IO.outValveRetract := NOT activeAllOffCmd;
            IO.outValveAdvance := FALSE;
            
            // Run retract timer
            retractTimer(IN := TRUE, PT := DINT_TO_TIME(cfg.cfgRetTimeoutS * 1000));
            
            // Check for successful retract
            IF IO.inFbkRetracted AND NOT IO.inFbkAdvanced THEN
                currentState := E_TwoPosActuator_State.Retracted;
                retractTimer(IN := FALSE); // Reset timer
            
            // Check for timeout
            ELSIF retractTimer.Q THEN
                currentState := E_TwoPosActuator_State.Fault;
                Status.faultCode := E_TwoPosActuator_Fault.RetractTimeout;
                faultLatched := TRUE;
                retractTimer(IN := FALSE); // Reset timer
            
            // Check for fault conditions during motion
            ELSIF bothFeedbackActive THEN
                currentState := E_TwoPosActuator_State.Fault;
                Status.faultCode := E_TwoPosActuator_Fault.BothFeedbackOn;
                faultLatched := TRUE;
                retractTimer(IN := FALSE); // Reset timer
            
            // Check if permissives are lost during motion
            ELSIF NOT retractPermissives.stsOK THEN
                currentState := E_TwoPosActuator_State.Fault;
                Status.faultCode := E_TwoPosActuator_Fault.PermissivesNotOK;
                faultLatched := TRUE;
                retractTimer(IN := FALSE); // Reset timer
            END_IF;
        
        E_TwoPosActuator_State.Fault:
            //---------------------------------------------------------------------
            // FAULT STATE
            //---------------------------------------------------------------------
            
            // De-energize both outputs in fault state
            IO.outValveAdvance := FALSE;
            IO.outValveRetract := FALSE;
            
            // Stop timers
            advanceTimer(IN := FALSE);
            retractTimer(IN := FALSE);
            
            // Fault is cleared by reset command (handled above)
    END_CASE;
    
    //-------------------------------------------------------------------------
    // Status Output Generation
    //-------------------------------------------------------------------------
    
    // Update status structure
    Status.state := currentState;
    Status.stsAdvanced := (currentState = E_TwoPosActuator_State.Advanced);
    Status.stsRetracted := (currentState = E_TwoPosActuator_State.Retracted);
    Status.stsMoving := (currentState = E_TwoPosActuator_State.Advancing) OR 
                       (currentState = E_TwoPosActuator_State.Retracting);
    Status.stsFaulted := (currentState = E_TwoPosActuator_State.Fault) OR faultLatched;
    Status.lastFaultCode := lastFault;
    
    // Generate one-shots for position reached
    rTrigAdvanced(CLK := Status.stsAdvanced);
    Status.osAdvanced := rTrigAdvanced.Q;
    
    rTrigRetracted(CLK := Status.stsRetracted);
    Status.osRetracted := rTrigRetracted.Q;
    
    //-------------------------------------------------------------------------
    // HMI Status Update
    //-------------------------------------------------------------------------
    
    // Copy status to HMI
    HMI.sts := Status;
    
ELSE
    // Disabled - de-energize outputs and reset timers
    IO.outValveAdvance := FALSE;
    IO.outValveRetract := FALSE;
    advanceTimer(IN := FALSE);
    retractTimer(IN := FALSE);
END_IF;]]></ST>
    </Implementation>
    <LineIds Name="FB_TwoPosActuator">
      <LineId Id="1" Count="296" />
    </LineIds>
  </POU>
</TcPlcObject>
