<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.13">
  <POU Name="FB_StateMachine" Id="{7408693c-f749-4b9e-8684-bfcba9889df8}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'hide_all_locals'} // Hides all local variables
FUNCTION_BLOCK FB_StateMachine
VAR_INPUT
    EnableIn : BOOL;                     // Enable input for the function block
    cfgAutoRun : BOOL;                   // Configuration for auto-run capability
    inpAutoIntlk : INT := -1;            // Auto interlock input bits
    inpBlockedCondition : DINT;          // Blocked condition input
    inpHomePerm : INT := -1;             // Home permission input bits
    inpProceedPerm : INT := -1;          // Proceed permission input bits
    inpStartPerm : INT := -1;            // Start permission input bits
    inpStarvedCondition : DINT;          // Starved condition input
    inpSubmoduleFaulted : BOOL;          // Submodule fault indicator
    NextStep : DINT;                     // Next step to transition to
END_VAR

VAR_OUTPUT
    EnableOut : BOOL;                    // Enable output for the function block
    outRetry : BOOL;                     // Retry output signal
    Status : ST_SM_Status;               // Status outputs (grouped)
    Permissions : ST_SM_Permissions;     // Permission status outputs (grouped)
    StepInfo : ST_SM_StepInfo;           // Step information (grouped)
    ConditionStatus : ST_SM_Conditions;  // Condition status (grouped)
END_VAR

VAR CONSTANT
    internalClearStep : ActiveStep;      // Constant for clearing a step
    EmptyHMIPerm : ST_PermIntlk_HMI;     // Empty HMI permissions structure
    
    // State constants
    STATE_IDLE : INT := 0;
    STATE_RUNNING : INT := 1;
    STATE_STOPPING : INT := 2;
    STATE_HOMING : INT := 4;
    STATE_ABORTING : INT := 8;
    STATE_HOMED : INT := 16;
    STATE_STOPPED : INT := 32;
    STATE_ABORTED : INT := 64;
    STATE_COMPLETE : INT := 128;
    STATE_PAUSING : INT := 256;
    STATE_PAUSED : INT := 512;
    STATE_PROCEEDING : INT := 1024;

END_VAR

VAR
    // Command request tracking
    CommandsRequested : ST_SM_Commands;  // Track command requests
    RetryComplete : BOOL;                // Flag for retry completion
    
    // Timer
    StepTimer : TON;                     // Step timer
    
    // Edge detection for commands
    R_TRIG_1 : R_TRIG;                  // For step transition
    R_TRIG_2 : R_TRIG;                  // For command retry
    R_TRIG_3 : R_TRIG;                  // For HMI retry
    R_TRIG_4 : R_TRIG;                  // For state transitions
    
    // Internal state tracking
    PauseStep : ActiveStep;              // Store step during pause
    PreviousState : DINT;                // Previous state
    TimerReset : BOOL;                   // Flag to reset timer
    LsOdd : DINT;                        // Odd step check for fault detection
    ONS : DINT;                          // General one-shot
    StepHistoryMax : DINT;               // Step history maximum
    ReturnState : DINT;                  // Return state after pause
    ReturnNextStep : DINT;               // Return next step after pause
    
    // Permission handlers
    internalAutoIntlk : FB_Permissives;       // Auto interlock handler
    internalHomePerm : FB_Permissives;        // Home permission handler
    internalProceedPerm : FB_Permissives;     // Proceed permission handler
    internalStartPerm : FB_Permissives;       // Start permission handler
    
    // Configuration for permission handlers
    homePermCfg : ST_PermIntlk_cfg;      // Configuration for home permission handler
    startPermCfg : ST_PermIntlk_cfg;     // Configuration for start permission handler
    proceedPermCfg : ST_PermIntlk_cfg;   // Configuration for proceed permission handler
    autoIntlkCfg : ST_PermIntlk_cfg;     // Configuration for auto interlock handler
    
    // HMI data structures for permissions
    internalAutoIntlk_HMI : ST_PermIntlk_HMI;  // Auto interlock HMI structure
    internalHomePerm_HMI : ST_PermIntlk_HMI;   // Home permission HMI structure
    internalProceedPerm_HMI : ST_PermIntlk_HMI; // Proceed permission HMI structure
    internalStartPerm_HMI : ST_PermIntlk_HMI;  // Start permission HMI structure
    
    // Temp variables for step detection
    stepIsZero : BOOL;                   // Flag for zero step
    retryCmdActive : BOOL;               // Flag for retry command
    retryHmiActive : BOOL;               // Flag for HMI retry
    transitionActive : BOOL;             // Flag for state transition
END_VAR

VAR_IN_OUT 
    HMI : SM_HMI;                        // HMI interface
    CurrentStep : ActiveStep;            // Current active step
	Commands : ST_SM_Commands;           // Command inputs (grouped)
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[
//-----------------------------------------------------------------------------
// Main Implementation
//-----------------------------------------------------------------------------
EnableOut := EnableIn;

// Only execute if enabled
IF EnableIn THEN
    //-------------------------------------------------------------------------
    // Process permissions for different states
    //-------------------------------------------------------------------------
    
    // Update configuration from HMI
    homePermCfg := internalHomePerm_HMI.cfg;
    startPermCfg := internalStartPerm_HMI.cfg;
    proceedPermCfg := internalProceedPerm_HMI.cfg;
    autoIntlkCfg := internalAutoIntlk_HMI.cfg;
    
    // Home permission evaluation
    internalHomePerm(
        inPermissives := inpHomePerm,
        cfg := homePermCfg
    );
    Permissions.HomePermOK := internalHomePerm.stsOK;
    internalHomePerm_HMI.sts.OK := internalHomePerm.stsOK;
    internalHomePerm_HMI.sts.PermIntlk := internalHomePerm.PermStatus;
    
    // Start permission evaluation
    internalStartPerm(
        inPermissives := inpStartPerm,
        cfg := startPermCfg
    );
    Permissions.StartPermOK := internalStartPerm.stsOK;
    internalStartPerm_HMI.sts.OK := internalStartPerm.stsOK;
    internalStartPerm_HMI.sts.PermIntlk := internalStartPerm.PermStatus;
    
    // Proceed permission evaluation
    internalProceedPerm(
        inPermissives := inpProceedPerm,
        cfg := proceedPermCfg
    );
    Permissions.ProceedPermOK := internalProceedPerm.stsOK;
    internalProceedPerm_HMI.sts.OK := internalProceedPerm.stsOK;
    internalProceedPerm_HMI.sts.PermIntlk := internalProceedPerm.PermStatus;
    
    // Auto interlock evaluation
    internalAutoIntlk(
        inPermissives := inpAutoIntlk,
        cfg := autoIntlkCfg
    );
    Permissions.AutoIntlkOK := internalAutoIntlk.stsOK;
    internalAutoIntlk_HMI.sts.OK := internalAutoIntlk.stsOK;
    internalAutoIntlk_HMI.sts.PermIntlk := internalAutoIntlk.PermStatus;
    
    //-------------------------------------------------------------------------
    // Ready state calculations
    //-------------------------------------------------------------------------
    
    // Ready to Home: Stopped or Aborted + Home permissions OK + Auto interlock OK
    Status.ReadyToHome := (Status.Stopped OR Status.Aborted) AND 
                          Permissions.HomePermOK AND 
                          Permissions.AutoIntlkOK;
    
    // Ready to Start: (Homed or Complete) + Start permissions OK + Auto interlock OK + Not auto-start requested
    Status.ReadyToStart := (Status.Homed OR Status.Complete) AND 
                          Permissions.StartPermOK AND 
                          Permissions.AutoIntlkOK AND 
                          NOT Status.AutoStartRequest;
    
    // Ready to Proceed: Paused + Proceed permissions OK + Auto interlock OK
    Status.ReadyToProceed := Status.Paused AND 
                            Permissions.ProceedPermOK AND 
                            Permissions.AutoIntlkOK;

    //-------------------------------------------------------------------------
    // Clear Active Step if in waiting state
    //-------------------------------------------------------------------------
    IF Status.Homed OR Status.Complete OR Status.Stopped OR Status.Aborted THEN
        CurrentStep := internalClearStep;
    END_IF;
    
    // Clear pause step on proceeding or aborting
    transitionActive := Status.Proceeding OR Status.Aborting;
    R_TRIG_4(CLK := transitionActive);
    IF R_TRIG_4.Q THEN
        PauseStep := internalClearStep;
    END_IF;
    
    //-------------------------------------------------------------------------
    // Auto-start request logic
    //-------------------------------------------------------------------------
    
    // Auto start request handling
    Status.AutoStartRequest := CommandsRequested.Start AND NOT Permissions.StartPermOK;
    
    // Auto cycle request for auto-run when complete
    Status.AutoCycleRequest := cfgAutoRun AND Status.Complete AND NOT Permissions.StartPermOK;
    
    //-------------------------------------------------------------------------
    // Remember last state before change
    //-------------------------------------------------------------------------
    PreviousState := StepInfo.CurrentState;
    
    //-------------------------------------------------------------------------
    // Process command requests
    //-------------------------------------------------------------------------
    
    // Complete State Request
    IF Commands.CompleteState THEN
        CommandsRequested.CompleteState := TRUE;
        Commands.CompleteState := FALSE;  // Reset command
        // Clear other requests
        CommandsRequested.Start := FALSE;
        CommandsRequested.Abort := FALSE;
        CommandsRequested.Pause := FALSE;
        CommandsRequested.Home := FALSE;
        CommandsRequested.Proceed := FALSE;
        CommandsRequested.Stop := FALSE;
    END_IF;
    
    // Start Request
    IF Commands.Start OR HMI.ocmd.Start THEN
        IF Permissions.AutoIntlkOK AND Permissions.StartPermOK AND (Status.Homed OR Status.Complete) THEN
            CommandsRequested.Start := TRUE;
        END_IF;
        
        IF CommandsRequested.Start AND (Status.Homed OR Status.Complete OR Status.Stopped) OR Status.AutoStartRequest THEN
            CommandsRequested.Start := TRUE;
        END_IF;
        
        // Clear command signals
        IF Commands.Start THEN
            Commands.Start := FALSE;
        END_IF;
        
        IF HMI.ocmd.Start THEN
            HMI.ocmd.Start := FALSE;
        END_IF;
    END_IF;
    
    // Clear other requests if Start is requested
    IF CommandsRequested.Start THEN
        CommandsRequested.Abort := FALSE;
        CommandsRequested.Pause := FALSE;
        CommandsRequested.Home := FALSE;
        CommandsRequested.Proceed := FALSE;
        CommandsRequested.Stop := FALSE;
        CommandsRequested.CompleteState := FALSE;
    END_IF;
    
    // Auto-run handling
    IF cfgAutoRun AND Permissions.AutoIntlkOK AND Permissions.StartPermOK AND Status.Complete THEN
        CommandsRequested.Start := TRUE;
    END_IF;
    
    // Home Request
    IF Commands.Home OR HMI.ocmd.Home THEN
        IF (Status.Stopped OR Status.Aborted) AND Permissions.HomePermOK AND Permissions.AutoIntlkOK THEN
            CommandsRequested.Home := TRUE;
        END_IF;
        
        // Clear other requests
        CommandsRequested.Abort := FALSE;
        CommandsRequested.Pause := FALSE;
        CommandsRequested.Proceed := FALSE;
        CommandsRequested.Start := FALSE;
        CommandsRequested.Stop := FALSE;
        CommandsRequested.CompleteState := FALSE;
        
        // Clear command signals
        IF Commands.Home THEN
            Commands.Home := FALSE;
        END_IF;
        
        IF HMI.ocmd.Home THEN
            HMI.ocmd.Home := FALSE;
        END_IF;
    END_IF;
    
    // Pause Request
    IF Commands.Pause OR HMI.ocmd.Pause THEN
        CommandsRequested.Pause := TRUE;
        
        // Clear other requests
        CommandsRequested.Abort := FALSE;
        CommandsRequested.Home := FALSE;
        CommandsRequested.Proceed := FALSE;
        CommandsRequested.Start := FALSE;
        CommandsRequested.Stop := FALSE;
        CommandsRequested.CompleteState := FALSE;
        
        // Clear command signals
        IF Commands.Pause THEN
            Commands.Pause := FALSE;
        END_IF;
        
        IF HMI.ocmd.Pause THEN
            HMI.ocmd.Pause := FALSE;
        END_IF;
    END_IF;
    
    // Proceed Request
    IF Commands.Proceed OR HMI.ocmd.Proceed THEN
        IF Permissions.ProceedPermOK AND Permissions.AutoIntlkOK THEN
            CommandsRequested.Proceed := TRUE;
        END_IF;
        
        // Clear other requests
        CommandsRequested.Abort := FALSE;
        CommandsRequested.Home := FALSE;
        CommandsRequested.Pause := FALSE;
        CommandsRequested.Start := FALSE;
        CommandsRequested.Stop := FALSE;
        CommandsRequested.CompleteState := FALSE;
        
        // Clear command signals
        IF Commands.Proceed THEN
            Commands.Proceed := FALSE;
        END_IF;
        
        IF HMI.ocmd.Proceed THEN
            HMI.ocmd.Proceed := FALSE;
        END_IF;
    END_IF;
    
    // Stop Request
    IF Commands.Stop OR HMI.ocmd.Stop THEN
        CommandsRequested.Stop := TRUE;
        
        // Clear other requests
        CommandsRequested.Abort := FALSE;
        CommandsRequested.Home := FALSE;
        CommandsRequested.Proceed := FALSE;
        CommandsRequested.Start := FALSE;
        CommandsRequested.Pause := FALSE;
        CommandsRequested.CompleteState := FALSE;
        
        // Clear command signals
        IF Commands.Stop THEN
            Commands.Stop := FALSE;
        END_IF;
        
        IF HMI.ocmd.Stop THEN
            HMI.ocmd.Stop := FALSE;
        END_IF;
    END_IF;
    
    // Abort Request
    IF Commands.Abort OR HMI.ocmd.Abort THEN
        CommandsRequested.Abort := TRUE;
        
        // Clear other requests
        CommandsRequested.Stop := FALSE;
        CommandsRequested.Home := FALSE;
        CommandsRequested.Proceed := FALSE;
        CommandsRequested.Start := FALSE;
        CommandsRequested.Pause := FALSE;
        CommandsRequested.CompleteState := FALSE;
        
        // Clear command signals
        IF Commands.Abort THEN
            Commands.Abort := FALSE;
        END_IF;
        
        IF HMI.ocmd.Abort THEN
            HMI.ocmd.Abort := FALSE;
        END_IF;
    END_IF;
    
    //-------------------------------------------------------------------------
    // State Transitions
    //-------------------------------------------------------------------------
    
    // Complete to Homed
    IF CommandsRequested.CompleteState AND Status.Homing THEN
        NextStep := 0;
        StepInfo.CurrentState := STATE_HOMED;
        CommandsRequested.CompleteState := FALSE;  // Clear after transition
    END_IF;
    
    // Running to Complete
    IF CommandsRequested.CompleteState AND Status.Running THEN
        NextStep := 0;
        StepInfo.CurrentState := STATE_COMPLETE;
        CommandsRequested.CompleteState := FALSE;  // Clear after transition
    END_IF;
    
    // Running to Stopping
    IF CommandsRequested.Stop AND Status.Running THEN
        StepInfo.CurrentState := STATE_STOPPING;
    END_IF;
    
    // Stopping to Stopped
    IF CommandsRequested.CompleteState AND Status.Stopping THEN
        NextStep := 0;
        StepInfo.CurrentState := STATE_STOPPED;
        CommandsRequested.CompleteState := FALSE;  // Clear after transition
    END_IF;
    
    // Aborting to Aborted
    IF CommandsRequested.CompleteState AND Status.Aborting THEN
        NextStep := 0;
        StepInfo.CurrentState := STATE_ABORTED;
        CommandsRequested.CompleteState := FALSE;  // Clear after transition
    END_IF;
    
    // Active State to Pausing
    // Handle state transitions to Pausing and remember the state to return to
    IF CommandsRequested.Pause AND (
        Status.Homing OR Status.Stopping OR Status.Aborting OR 
        Status.Homed OR Status.Complete OR Status.Proceeding OR Status.Running) THEN
        
        // Remember the current state and next step for later return
        IF NOT (Status.Homed OR Status.Complete OR Status.Proceeding) THEN
            ReturnState := StepInfo.CurrentState;
            ReturnNextStep := NextStep;
        END_IF;
        
        // Save the current step for paused state
        IF NOT (Status.Homed OR Status.Complete OR Status.Proceeding) THEN
            PauseStep := CurrentStep;
        ELSE
            PauseStep := internalClearStep;
        END_IF;
        
        // Transition to pausing state
        StepInfo.CurrentState := STATE_PAUSING;
        NextStep := 0;
    END_IF;
    
    // Pausing to Paused
    IF CommandsRequested.CompleteState AND Status.Pausing THEN
        NextStep := 0;
        StepInfo.CurrentState := STATE_PAUSED;
        CommandsRequested.CompleteState := FALSE;  // Clear after transition
    END_IF;
    
    // Proceeding to Step before Pausing
    IF CommandsRequested.CompleteState AND Status.Proceeding THEN
        CurrentStep := PauseStep;
        NextStep := ReturnNextStep;
        StepInfo.CurrentState := ReturnState;
        CommandsRequested.CompleteState := FALSE;  // Clear after transition
    END_IF;
    
    // Homed to Running
    IF (CommandsRequested.Start OR 
        (Status.AutoStartRequest AND Permissions.StartPermOK AND Permissions.AutoIntlkOK)) AND 
        (Status.Homed OR Status.Complete) THEN
        
        NextStep := 0;
        StepInfo.CurrentState := STATE_RUNNING;
        CommandsRequested.Start := FALSE;
    END_IF;
    
    // Homed to Stopped
    IF CommandsRequested.Stop AND Status.Homed THEN
        NextStep := 0;
        StepInfo.CurrentState := STATE_STOPPED;
    END_IF;
    
    // Complete to Stopped
    IF CommandsRequested.Stop AND Status.Complete THEN
        NextStep := 0;
        StepInfo.CurrentState := STATE_STOPPED;
    END_IF;
    
    // Stopped or Aborted to Homing
    IF CommandsRequested.Home AND (Status.Stopped OR Status.Aborted) THEN
        NextStep := 0;
        StepInfo.CurrentState := STATE_HOMING;
    END_IF;
    
    // Paused to Proceeding
    IF CommandsRequested.Proceed AND Status.Paused THEN
        NextStep := 0;
        StepInfo.CurrentState := STATE_PROCEEDING;
    END_IF;
    
    // Abort (from any state except Stopped/Aborted/Aborting)
    IF CommandsRequested.Abort AND NOT (Status.Stopped OR Status.Aborted OR Status.Aborting) THEN
        NextStep := 0;
        StepInfo.CurrentState := STATE_ABORTING;
    END_IF;
    
    //-------------------------------------------------------------------------
    // Save last state when changing
    //-------------------------------------------------------------------------
    IF StepInfo.CurrentState <> PreviousState THEN
        StepInfo.LastState := PreviousState;
    END_IF;
    
    //-------------------------------------------------------------------------
    // Update status flags based on current state
    //-------------------------------------------------------------------------
    // Reset all status flags first
    Status.Running := FALSE;
    Status.Stopping := FALSE;
    Status.Homing := FALSE;
    Status.Aborting := FALSE;
    Status.Homed := FALSE;
    Status.Stopped := FALSE;
    Status.Aborted := FALSE;
    Status.Complete := FALSE;
    Status.Pausing := FALSE;
    Status.Paused := FALSE;
    Status.Proceeding := FALSE;
    
    // Set corresponding status flag based on current state
    CASE StepInfo.CurrentState OF
        STATE_RUNNING:
            Status.Running := TRUE;
            StepInfo.StateString := 'Running';
        
        STATE_STOPPING:
            Status.Stopping := TRUE;
            StepInfo.StateString := 'Stopping';
        
        STATE_HOMING:
            Status.Homing := TRUE;
            StepInfo.StateString := 'Homing';
        
        STATE_ABORTING:
            Status.Aborting := TRUE;
            StepInfo.StateString := 'Aborting';
        
        STATE_HOMED:
            Status.Homed := TRUE;
            StepInfo.StateString := 'Homed';
        
        STATE_STOPPED:
            Status.Stopped := TRUE;
            StepInfo.StateString := 'Stopped';
        
        STATE_ABORTED:
            Status.Aborted := TRUE;
            StepInfo.StateString := 'Aborted';
        
        STATE_COMPLETE:
            Status.Complete := TRUE;
            StepInfo.StateString := 'Complete';
        
        STATE_PAUSING:
            Status.Pausing := TRUE;
            StepInfo.StateString := 'Pausing';
        
        STATE_PAUSED:
            Status.Paused := TRUE;
            StepInfo.StateString := 'Paused';
        
        STATE_PROCEEDING:
            Status.Proceeding := TRUE;
            StepInfo.StateString := 'Proceeding';
    END_CASE;
    
    // Set the active/waiting state flags
    Status.WaitingState := Status.Homed OR Status.Complete OR Status.Stopped OR Status.Paused OR Status.Aborted;
    Status.ActiveState := Status.Homing OR Status.Running OR Status.Stopping OR Status.Pausing OR Status.Proceeding OR Status.Aborting;
    
    // Set mode (0 = Manual, 1 = Automatic)
    IF Status.Stopped OR Status.Aborted OR Status.Paused THEN
        Status.Mode := 0;
        Status.Manual := TRUE;
        Status.Automatic := FALSE;
    ELSE
        Status.Mode := 1;
        Status.Manual := FALSE;
        Status.Automatic := TRUE;
    END_IF;
    
    //-------------------------------------------------------------------------
    // Step and timer management
    //-------------------------------------------------------------------------
    
    // Clear ActiveStep when transitioning to step 0 (when step becomes zero)
    stepIsZero := (StepInfo.CurrentStep = 0);
    R_TRIG_1(CLK := stepIsZero);
    IF R_TRIG_1.Q THEN
        CurrentStep := internalClearStep;
    END_IF;
    
    // Update step when NextStep changes - AFTER clearing logic
    IF StepInfo.CurrentStep <> NextStep THEN
        StepInfo.CurrentStep := NextStep;
        TimerReset := TRUE;
    END_IF;
    
    // Synchronize shared CurrentStep.Step with internal step tracking - AFTER all step updates
    IF CurrentStep.Step <> StepInfo.CurrentStep THEN
        CurrentStep.Step := StepInfo.CurrentStep;
    END_IF;
    
    // Step timer logic
    IF NOT Status.Paused OR (Status.Paused AND CommandsRequested.CompleteState) THEN
        IF TimerReset THEN
            // Reset the timer by setting IN to FALSE for one scan
            StepTimer(IN := FALSE);
        ELSE
            // Normal timer operation
            StepTimer.PT := T#99H;
            StepTimer(IN := TRUE);
        END_IF;
    ELSE
        StepTimer(IN := FALSE);
    END_IF;
    
    // Convert timer value to seconds
    StepInfo.StepTimerSeconds := UDINT_TO_REAL(TIME_TO_UDINT(StepTimer.ET)) / 1000.0;
    
    // Reset timer flag when step matches NextStep (after timer has been reset)
    IF TimerReset AND StepInfo.CurrentStep = NextStep THEN
        TimerReset := FALSE;
    END_IF;
    
    //-------------------------------------------------------------------------
    // Fault detection
    //-------------------------------------------------------------------------
    
    // Check if step is odd (indicates fault)
    LsOdd := StepInfo.CurrentStep MOD 2;
    Status.Faulted := LsOdd <> 0;
    
    // Submodule fault handling
    Status.SubmoduleFaulted := inpSubmoduleFaulted;
    
    //-------------------------------------------------------------------------
    // Retry logic
    //-------------------------------------------------------------------------
    
    // Retry command from command input
    retryCmdActive := Commands.Retry;
    R_TRIG_2(CLK := retryCmdActive);
    IF R_TRIG_2.Q THEN
        outRetry := TRUE;
        Commands.Retry := FALSE;
    END_IF;
    
    // Retry command from HMI
    retryHmiActive := HMI.ocmd.Retry;
    R_TRIG_3(CLK := retryHmiActive);
    IF R_TRIG_3.Q THEN
        outRetry := TRUE;
        HMI.ocmd.Retry := FALSE;
    END_IF;
    
    // Ensure retry signal stays on for at least one scan
    IF RetryComplete THEN
        outRetry := FALSE;
        RetryComplete := FALSE;
    END_IF;
    
    IF outRetry THEN
        RetryComplete := TRUE;
    END_IF;
    
    //-------------------------------------------------------------------------
    // Blocked and Starved condition handling for OEE
    //-------------------------------------------------------------------------
    
    // Reset blocked condition if not present
    IF inpBlockedCondition = 0 THEN
        ConditionStatus.Blocked := 0;
    END_IF;
    
    // Check for blocked condition in appropriate states
    IF inpBlockedCondition <> 0 AND 
       (Status.Running OR Status.Stopping OR Status.Complete OR 
        (Status.Homed AND Status.AutoStartRequest)) THEN
        
        ConditionStatus.Blocked := inpBlockedCondition;
        Status.Blocked := TRUE;
        inpBlockedCondition := 0;
    END_IF;
    
    // Reset starved condition if not present
    IF inpStarvedCondition = 0 THEN
        ConditionStatus.Starved := 0;
    END_IF;
    
    // Check for starved condition in appropriate states
    IF inpStarvedCondition <> 0 AND 
       (Status.Running OR Status.Stopping OR Status.Complete OR 
        (Status.Homed AND Status.AutoStartRequest)) THEN
        
        ConditionStatus.Starved := inpStarvedCondition;
        Status.Starved := TRUE;
        inpStarvedCondition := 0;
    END_IF;
    
    //-------------------------------------------------------------------------
    // Update HMI data
    //-------------------------------------------------------------------------
    
    // Update HMI status information
    HMI.sts.Automatic := Status.Automatic;
    HMI.sts.Manual := Status.Manual;
    HMI.sts.Homing := Status.Homing;
    HMI.sts.Homed := Status.Homed;
    HMI.sts.Running := Status.Running;
    HMI.sts.Complete := Status.Complete;
    HMI.sts.Stopping := Status.Stopping;
    HMI.sts.Stopped := Status.Stopped;
    HMI.sts.Aborting := Status.Aborting;
    HMI.sts.Aborted := Status.Aborted;
    HMI.sts.Pausing := Status.Pausing;
    HMI.sts.Paused := Status.Paused;
    HMI.sts.Proceeding := Status.Proceeding;
    HMI.sts.Faulted := Status.Faulted;
    HMI.sts.ChildFaulted := Status.SubmoduleFaulted;
    HMI.sts.ReadyToHome := Status.ReadyToHome;
    HMI.sts.ReadyToProceed := Status.ReadyToProceed;
    HMI.sts.ReadyToStart := Status.ReadyToStart;
    HMI.sts.AutoStartRequest := Status.AutoStartRequest;
    HMI.sts.AutoCycleRequest := Status.AutoCycleRequest;
    HMI.sts.Blocked := Status.Blocked;
    HMI.sts.Starved := Status.Starved;
    
    // Update permission states in HMI
    IF Status.Stopped OR Status.Aborted THEN
        HMI.NextStatePerms := internalHomePerm_HMI;
    END_IF;
    
    IF Status.Homed OR Status.Complete THEN
        HMI.NextStatePerms := internalStartPerm_HMI;
    END_IF;
    
    IF Status.Paused THEN
        HMI.NextStatePerms := internalProceedPerm_HMI;
    END_IF;
    
    // Update active step information
    IF Status.ActiveState THEN
        // Create a HMI structure with the current step's permission config
        internalHomePerm_HMI.cfg := CurrentStep.PermsHMI;
        HMI.ActiveStepHMI := internalHomePerm_HMI;
    ELSE
        HMI.ActiveStepHMI := HMI.NextStatePerms;
    END_IF;
    
ELSE
    // Reset command requests when disabled
    CommandsRequested.Start := FALSE;
    CommandsRequested.Stop := FALSE;
    CommandsRequested.Home := FALSE;
    CommandsRequested.Abort := FALSE;
    CommandsRequested.Pause := FALSE;
    CommandsRequested.Proceed := FALSE;
    CommandsRequested.CompleteState := FALSE;
END_IF;
]]></ST>
    </Implementation>
    <LineIds Name="FB_StateMachine">
      <LineId Id="2919" Count="633" />
      <LineId Id="9" Count="0" />
      <LineId Id="638" Count="7" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>